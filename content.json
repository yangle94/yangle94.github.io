[{"title":"使用docker、nginx、nginx-gen、letsencrypt个人主站升级https","date":"2017-11-30T01:25:13.000Z","path":"2017/11/30/websiteHttps/","text":"准备工具 docker docker-compose nginx 镜像 jwilder/docker-gen 镜像 jrcs/letsencrypt-nginx-proxy-companion 镜像 执行操作 拷贝一份 .env.sample 并改名为.env 12cp .env.sample ./.env 修改.env文件的内容 1234567891011NGINX_WEB=nginx-web #nginx的容器的名字DOCKER_GEN=nginx-gen #nginx-gen容器的名字LETS_ENCRYPT=nginx-letsencrypt #letsencrypt容器的名字IP=0.0.0.0 #公网IP名，（可以不用管，0.0.0.0就好）# Network nameNETWORK=webproxy #docker network的名字# NGINX file pathNGINX_FILES_PATH=/path/to/your/nginx/data #三个容器共享路径 执行 run.sh 12./run.sh 或者 sh run.sh 运行一个测试容器 123456执行一个http协议访问容器:docker run -d -e VIRTUAL_HOST=your.domain.com \\ --network=webproxy \\ --name my_app \\ httpd:alpine 123456789执行一个https协议访问容器:docker run -d -e VIRTUAL_HOST=your.domain.com \\ -e LETSENCRYPT_HOST=your.domain.com \\ -e LETSENCRYPT_EMAIL=your.email@your.domain.com \\ -e VIRTUAL_PORT=3000 #设置监听端口 --network=webproxy \\ --name my_app \\ httpd:alpine 此处，请务必把所有需要https代理的容器跟 nginx的三个容器放入同一个network中！原理1.jwilder/docker-gen镜像用来反向生成nginx配置文件，jrcs/letsencrypt-nginx-proxy-companion镜像用来根据生成的配置文件（域名）申请https证书，会自动进行检测，如果过期，自动申请新的https证书。 2.如果要对新的docker镜像使用https，请务必带上LETSENCRYPT_HOST、 LETSENCRYPT_HOST、LETSENCRYPT_EMAIL这三个属性。","tags":[{"name":"Docker、Https、Nginx","slug":"Docker、Https、Nginx","permalink":"https://yangle94.github.io/tags/Docker、Https、Nginx/"}]},{"title":"通过docker创建SonarQube代码质量检测平台","date":"2017-10-27T02:13:08.000Z","path":"2017/10/27/makeSonarQube/","text":"作为一个程序，想要写出更健壮的代码，一个好的代码检测工具是必不可少的。某天突然发现了一个代码检测平台工具SonarQube，想要安装一下，发现有docker版本的，特别来安利一下。 1. 安装postgresql1docker run --name postgresql -e POSTGRES_USER=sonarqube -e POSTGRES_PASSWORD=sonarqube -d postgres 2. 安装sonarqube1docker run --name sq --link postgresql -e SONARQUBE_JDBC_URL=jdbc:postgresql://postgresql:5432/sonarqube -e SONARQUBE_JDBC_USERNAME=sonarqube -e SONARQUBE_JDBC_PASSWORD=sonarqube -p 9000:9000 -d sonarqube 3. 平台搭建完成 打开 localhost:9000，进行登录，（初始账户为admin,admin），登录成功后会有教程弹出。 2.汉化： 4 附上链接sonarqube docker hub地址spring4all 教程地址汉化参考","tags":[{"name":"Docker、SonarQube","slug":"Docker、SonarQube","permalink":"https://yangle94.github.io/tags/Docker、SonarQube/"}]},{"title":"SpringCloud记录点","date":"2017-09-26T03:32:35.000Z","path":"2017/09/26/springCloudUtil/","text":"忽略网络接口application.yml: 123456spring: cloud: inetutils: ignoredInterfaces: - docker0 - veth.* 代码位置:org.springframework.cloud.commons.util.InetUtilsProperties 1234/** * List of Java regex expressions for network addresses that will be * preferred. */private List&lt;String&gt; preferredNetworks = new ArrayList&lt;&gt;(); 这个类是一个一个网络工具类的配置文件属性类，由注释可得，preferredNetworks承载了所有需要进行忽略的网络连接名的正则表达式。查看其使用位置 123456789boolean ignoreInterface(String interfaceName) &#123; for (String regex : this.properties.getIgnoredInterfaces()) &#123; if (interfaceName.matches(regex)) &#123; log.trace(\"Ignoring interface: \" + interfaceName); return true; &#125; &#125; return false; &#125; 查看ignoreInterface所调用的位置： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public InetAddress findFirstNonLoopbackAddress() &#123; InetAddress result = null; try &#123; int lowest = Integer.MAX_VALUE; for (Enumeration&lt;NetworkInterface&gt; nics = NetworkInterface .getNetworkInterfaces(); nics.hasMoreElements();) &#123; NetworkInterface ifc = nics.nextElement(); if (ifc.isUp()) &#123; log.trace(\"Testing interface: \" + ifc.getDisplayName()); if (ifc.getIndex() &lt; lowest || result == null) &#123; lowest = ifc.getIndex(); &#125; else if (result != null) &#123; continue; &#125; // @formatter:off if (!ignoreInterface(ifc.getDisplayName())) &#123; for (Enumeration&lt;InetAddress&gt; addrs = ifc .getInetAddresses(); addrs.hasMoreElements();) &#123; InetAddress address = addrs.nextElement(); if (address instanceof Inet4Address &amp;&amp; !address.isLoopbackAddress() &amp;&amp; !ignoreAddress(address)) &#123; log.trace(\"Found non-loopback interface: \" + ifc.getDisplayName()); result = address; &#125; &#125; &#125; // @formatter:on &#125; &#125; &#125; catch (IOException ex) &#123; log.error(\"Cannot get first non-loopback address\", ex); &#125; if (result != null) &#123; return result; &#125; try &#123; return InetAddress.getLocalHost(); &#125; catch (UnknownHostException e) &#123; log.warn(\"Unable to retrieve localhost\"); &#125; return null; &#125; SpringCloud进行注册的时候会调用本地方法获得当前宿主机的网络信息，在*nix下（包括Mac），类似于ifconfig命令所显示的内容，会遍历其中的内容，所有网卡下到上，然后分别每个网卡内部的地址，保留最后一个非回环地址。 我在当某台Linux机器（宿主机）安装了docker的时候，会安装一个docker0的网桥，docker0的网桥会在宿主机的第一个，导致在宿主机上运行的springboot（dubbo也会）会拿到错误的IP信息，当把docker0网卡加入到这个里头之后，就会避免这个问题。 强制使用正则表达式中的地址以及仅使用站点本地地址123456spring: cloud: inetutils: preferredNetworks: - 192.168 - 10.0 此配置同样位于org.springframework.cloud.commons.util.InetUtilsProperties 1234/** * Use only interfaces with site local addresses. See &#123;@link InetAddress#isSiteLocalAddress()&#125; for more details. */private boolean useOnlySiteLocalInterfaces = false; 查看参数使用位置： 123456boolean ignoreAddress(InetAddress address) &#123; if (this.properties.isUseOnlySiteLocalInterfaces() &amp;&amp; !address.isSiteLocalAddress()) &#123; log.trace(\"Ignoring address: \" + address.getHostAddress()); return true; &#125; 由此可见，当不设置的时候，useOnlySiteLocalInterfaces默认值为false，不管拿到的是公网地址还是内网地址，直接进行对下面正则的匹配，当正则不匹配并且地址不是以regex开头的，会返回true（注意方法名是ignoreAddress，true表示忽略，false表示不忽略），如果不匹配则返回false；当useOnlySiteLocalInterfaces设置为true时，如果此IP地址不是内网地址，则直接返回true，如果是内网地址，则进行正则匹配。","tags":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"https://yangle94.github.io/tags/SpringCloud/"}]},{"title":"自定义事件驱动","date":"2017-09-20T01:53:17.000Z","path":"2017/09/20/evenDriver1/","text":"","tags":[{"name":"even","slug":"even","permalink":"https://yangle94.github.io/tags/even/"}]},{"title":"Mac下hexo建站","date":"2017-05-26T08:46:38.000Z","path":"2017/05/26/creatHexo/","text":"刚开始建站的时候说过写一篇建站教程，由于当时建站以后因为工作上的各种事儿给耽误了，以后就再也没工夫写了，今天特地来补上。 准备材料 GitHubPages仓库 Node.js homebrew hexo git(由于Mac自带了，就不需要了) github上创建GitHubPages仓库git 官方参考地址: https://pages.github.com 注意： 创建仓库的时候仓库名一定严格按照 git用户名.github.io 来命名 创建仓库完成之后,再去创建一个其他的仓库，用于保存hexo的整个目录，用来当备份使用，名字随便取。 安装 homebrewhomebrew是Mac下的软件管理程序，类似于centos的yum。 homebrew官方网站 下载安装方法、更换国内镜像源等详情请google，目前我在这里仅仅提供部分命令 12brew update 更新brew列表brew search node.js 查询node.js（可以查看最新版本的node.js，然后brew install node7.js） hexo安装hexohexo官方网站 1npm install -g hexo-cli 安装hexo客户端 建站安装完成hexo后，执行建站命令。 123hexo init &lt;你要存放的目录&gt;cd &lt;你要存放的目录&gt;npm install 配置新建完成后，指定文件夹的目录如下： .├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── themes 打开_config.yml，此网站的大部分配置都在里面。 参数 描述 title 网站标题 subtitle 网站副标题 description 网站描述 author 您的名字 language 网站使用的语言 timezone 网站时区。Hexo 默认使用您电脑的时区。时区列表。比如说：America/New_York, Japan, 和 UTC 。 git账户地址以及分支 deploy: type: git repository: git@github.com:yangle94/yangle94.github.io.git branch: master 网址：请把你刚才申请的githubpages的地址放到这里的url,例如我的是https://yangle94.github.io， 就把他放到url后。 参数 描述 默认值 url 网址 root 网站根目录 permalink 文章的 永久链接 格式 :year/:month/:day/:title/ permalink_defaults 永久链接中各部分的默认值 切记切记，yml文件有特殊的配置，类似于键值对的 :后一定要有个空格，不然会报错！！！ hexo命令简介1234hexo s 开启本地访问服务器hexo d 上传文件hexo g 生成静态文件hexo clean 清理本地静态文件 备份在你刚才创建的目录下，使用git对源码进行备份，防止丢失。 在github上创建一个仓库专门用来存储此处的源代码，具体操作在github上创建仓库的时候会有提示，再此不进行教程了。 希望大家看完以后早日拥有自己的博客😍","tags":[{"name":"Mac","slug":"Mac","permalink":"https://yangle94.github.io/tags/Mac/"},{"name":"hexo","slug":"hexo","permalink":"https://yangle94.github.io/tags/hexo/"}]},{"title":"业务操作数据库时的注意事项","date":"2017-04-07T02:32:18.000Z","path":"2017/04/07/DBPrecautions/","text":"一次数据库崩溃引发的思考 前两天，因为写业务，操作数据库，因为sql不当操作，导致了数据库的崩溃，特此将其拿出进行反思和思考。 起因:由于业务的原因，为了保留历史记录，所以我在删除的时候使用了delete_flag进行逻辑删除，所以，删除命令就变为了 12SELECT * FROM tableNmae WHERE delete_flag = 0 UPDATE SET delete_flag = 1 FROM tableNmae = ? 分析此时，虽然看似已经实现了程序所需要的功能，其实隐含着很大的问题。当数据库增加、删除频率以及数据库条数很大的时候，此问题会暴露的十分严重，甚至数据库的崩溃。 首先，我想说的是逻辑删除并非不可用，不过要切实配合好insert以及查询，保证数据库中的重复率不会太高。我当时的错误的做法：使用select语句对数据库中的数据进行存在检测，如果不存在就增加一条，即SELECT * FROM tableNmae WHERE delete_flag = 0 ——-》 INSERT INTO tableName () VALUES (),如果有数据，就跳过。删除时，直接调用UPDATE SET delete_flag = 1 FROM tableNmae = ?。此时，如果删除、增加的数量一多，数据库中会存在非常多的已删除数据，并且在逻辑删除操作的时候，并未加入WHERE delete_flag = 0，导致会将所有的已经逻辑删除的数据再次的删除一遍，数据量一大，直接会将数据库拉崩溃，我当时逻辑删除一条数据所占用的记录数基本到了1000条，在高峰时段直接导致了数据库崩溃。 解决之道：针对此有几种解决方法: 最简单的方法：将逻辑删除换为物理删除，这样无论会有多少次的重复加入数据，在累加的过程中只会保证一条未删除数据的存在。 对逻辑删除加入WHERE delete_flag = 0 这个条件，用于减少一次性更新的条数。每次新增前查询数据库中是否存在对应的已经被删除相同数据，如果有，根据业务逻辑则逻辑删除其它未删除的数据，然后将这条数据的删除位标识更改为0，如果没有在进行增加。 总结：对于频繁的数据操作而言，一定要记得加入where条件使udpate语句更新最小的数量！！！！","tags":[{"name":"Java","slug":"Java","permalink":"https://yangle94.github.io/tags/Java/"},{"name":"AutoCloseable","slug":"AutoCloseable","permalink":"https://yangle94.github.io/tags/AutoCloseable/"}]},{"title":"swagger-ui注解","date":"2017-03-14T02:30:50.000Z","path":"2017/03/14/swagger-annotation/","text":"今天使用swagger的时候出现了不少一点问题，body传上来的Json字符串在swagger-ui上的形式总是不符合我的意愿，我找了好久才找到了问题。特别来记录一下。 注解列表@Api用在类上，说明该类的作用 @ApiOperation用在方法上，说明方法的作用(当方法所需参数为对象时，) @ApiImplicitParams、@ApiImplicitParam@ApiImplicitParams({ @ApiImplicitParam})用在@ApiImplicitParams注解中，指定一个请求参数的各个方面paramType:参数放在哪个地方&gt;header–&gt;请求参数的获取：@RequestHeaderquery–&gt;请求参数的获取：@RequestParampath（用于restful接口）–&gt;请求参数的获取：@PathVariablebody（不常用）form（不常用）name：参数名dataType：参数类型required：参数是否必须传value：参数的意思defaultValue：参数的默认值 @ApiResponses用于表示一组响应 @ApiResponse用在@ApiResponses中，一般用于表达一个错误的响应信息code：数字，例如400message：信息，例如”请求参数没填好”response：抛出异常的类 @ApiModel描述一个Model的信息（这种一般用在post创建的时候，使用@RequestBody这样的场景，请求参数无法使用@ApiImplicitParam注解进行描述的时候） @ApiModelProperty描述一个model的属性 注意事项对于@ApiImplicitParams、@ApiImplicitParam、@ApiModel、@ApiModelProperty的使用情景。首先，对于类似application/x-www-form-urlencoded等除了application/json以外的传输方式，其传输内容实质上是K-V的方式进行传递的，此时可以用@ApiImplicitParams、@ApiImplicitParam对所传入的参数进行描述，但是如果使用application/json的方式传输JSON字符串，这种表示方式是不可用的，因为无法准确表示字符串中每个字段所代表的值。此时，就应该使用 1234@ApiOperation(value=\"使用httpClient爬取页面\", notes=\"使用httpClient爬取页面\", produces = \"application/json\")@ApiImplicitParam(name = \"pageInfoDto\", value = \"用户详细实体user\", required = true, dataType = \"PageInfoDto\", paramType = \"body\")@RequestMapping(\"getValue\")public Result getValue(@RequestBody PageInfoDto pageInfoDto) &#123;&#125; 这个时候可以使用一个@ApiImplicitParam来描述所传JSON的信息，千万不可以用@ApiImplicitParams，否则swagger-ui的界面上会出现异常的参数形式。此时，可以配合@ApiModel、 @ApiModelProperty在当前参数的实体类上对信息进行描述。","tags":[{"name":"swagger-ui","slug":"swagger-ui","permalink":"https://yangle94.github.io/tags/swagger-ui/"}]},{"title":"maven上传文件到私库","date":"2017-03-08T03:14:14.000Z","path":"2017/03/08/maven-uploadJar/","text":"今天因为在服务器端对webp进行格式转换，发现对于webp的jar在maven的仓库里并没有发现。于是只好自己把webp的jar加入了maven私服。将代码进行copy，以备不时之需。12345发布到本地仓库：mvn install:install-file -DgroupId=[groupId] -DartifactId=[artifactId] -Dversion=[version] -Dpackaging=jar -Dfile=[path to file] 发布到Nexus仓库：mvn deploy:deploy-file -DgroupId==[groupId] -DartifactId=[artifactId] -Dversion=[version] -Dpackaging=jar -Dfile=[path to file] -Durl=[url] -DrepositoryId=[id]","tags":[{"name":"maven","slug":"maven","permalink":"https://yangle94.github.io/tags/maven/"}]},{"title":"带有资源的try语句（AutoCloseable）","date":"2017-03-08T01:45:02.000Z","path":"2017/03/08/AutoCloseable-Interface/","text":"今天在关闭输入输出流的时候，觉得总是手动去关闭太麻烦，有没有什么简单的方法。于是乎发现了AutoCloseable这个接口。 重申一下为什么要手动关闭输入输出流对于平常的Java对象来说，如果Java的gc机制发现某个对象已经不可到达，就会启动对此对象的内存回收机制。当然，他什么时候能够把对象回收完了，是根据操作系统的调度来决定的，并不是说gc机制一起动，就能立刻回收此对象的内存。但是对于InputStream和OutputStream以及他们的子类来说，如果开启了某个流，就会有操作系统之外的资源依附在某个Java对象上，这就导致gc认为其实活着的，而不是死亡的，所以并不能出发gc机制。 AutoCloseable接口在Java1.7中提供了新的AutoCloseable接口，以前的Closeable接口扩展了AutoCloseable接口，也就是说，所有的实现了Closeable接口的输入输出流全部实现了AutoCloseable接口，就是说所有的输入输出流都能进行带资源的try catch语句。 12345678910public class InputStreamReaderTest &#123; public static void main(String[] args) &#123; try(BufferedReader reader = new BufferedReader(new InputStreamReader( new FileInputStream(new File(\"/home/angle/test.webp\")),\"UTF8\"),1024))&#123; System.out.println(reader.readLine()); //这里直接读一行 &#125;catch(IOException e)&#123; e.printStackTrace(); &#125; &#125;&#125; 此时，就不需要我们自己手动去关闭输入、输出流了，带资源的try块儿会帮我们把资源管理好。 注：关于带资源的try语句的3个关键点：由带资源的try语句管理的资源必须是实现了AutoCloseable接口的类的对象。 在try代码中声明的资源被隐式声明为fianl。 通过使用分号分隔每个声明可以管理多个资源。","tags":[{"name":"Java","slug":"Java","permalink":"https://yangle94.github.io/tags/Java/"},{"name":"AutoCloseable","slug":"AutoCloseable","permalink":"https://yangle94.github.io/tags/AutoCloseable/"}]},{"title":"考虑用静态工厂方法替代构造函数","date":"2017-03-02T14:04:54.000Z","path":"2017/03/02/staticFactory/","text":"静态工厂方法优点 静态工厂方法有名称，根据名称可以做到见文知意。对于构造方法而言，由于方法签名的原因，一个类只可能一种相同的方法签名，当然，可以通过参数顺序来克服这个问题，但是，相同参数容易让人混乱，而且有可能错过了编译器的异常。 静态工厂方法可以不必每次调用它的时候都创建一个新的对象。 可以返回原返回类型的任何子类型对象。1234567891011121314151617181920212223242526272829303132333435363738public interface Service&#123; //do something&#125;public interface Provider&#123; Service newService();&#125;public class Service &#123; //不允许外部实例化 private Service()&#123;&#125;; private static final Map&lt;String,Provider&gt; providers = new ConcurrentHashMap&lt;&gt;(); public static final String defKey = \"&lt;def&gt;\"; //注册 public static void registerDefaultProvider(Provider provider) &#123; registerProvider(defKey, provider); &#125; public static void registerDefaultProvider(String name, Provider provider) &#123; providers.put(name, provider); &#125; //获取 public static Service newInstance() &#123; return newInstance(defkey); &#125; public static Service newInstance(String name) &#123; Provider p = providers.get(name); if(null == p) throw new IlleaglArgumentException(\"No provider registered with name : \" + name); return p.newService(); &#125;&#125; 缺点: 类如果不含有公有或者受保护的构造方法，就不能被子类化。因祸得福的是，我们鼓励复合，而不是继承。 静态工厂方法与普通静态方法没有任何区别，“赶着一等公民（构造方法）的活儿，却享受不到一等公民的待遇（Javadoc等工具并不关注静态工厂方法) 何时应该用静态工厂方法 如果需要大量含有共同签名的构造方法的时候。 每次返回的对象是不可变类的时候，可以提前构造好对象供其使用。 需要返回不同的子类的时候。 静态工厂方法命名 valueOf —- 返回值与参数具有相同的值 of —- valueOf的替代 geteInstance —- 通过参数描述返回实例，但是值不一定相同 newInstance —- 创建一个新的对象 getType —- Type表示返回的实例的类型 newType —- 返回一个新的实例","tags":[{"name":"JAVA","slug":"JAVA","permalink":"https://yangle94.github.io/tags/JAVA/"}]},{"title":"SpringMVC_Annotation_@RequestBody","date":"2017-03-01T11:33:40.000Z","path":"2017/03/01/SpringMVC-Annotation-RequestBody/","text":"@RequestBody注解的源码123456@Target(&#123;ElementType.PARAMETER&#125;)@Retention(RetentionPolicy.RUNTIME)@Documentedpublic @interface RequestBody &#123; boolean required() default true;&#125; 由源码可见，@RequestBody只有一个required属性，默认值为true，该注解会保留至.class文件中，利用反射可以进行查找。 @RequestBody的作用该注解常用来处理Content-Type: 不是application/x-www-form-urlencoded编码的内容，例如application/json, application/xml等； 它是通过使用HandlerAdapter 配置的HttpMessageConverters来解析post data body，然后绑定到相应的bean上的。 因为配置有FormHttpMessageConverter，所以也可以用来处理 application/x-www-form-urlencoded的内容，处理完的结果放在一个MultiValueMap里，这种情况在某些特殊需求下使用，详情查看FormHttpMessageConverter api; 例如1234@RequestMapping(value = \"sendMessage\", method = RequestMethod.POST)public String sendMesscage(@RequestBody UserIdCodeDTO userIdCodeMessageDTO) &#123; return userIdCodeMessageDTO.toString();&#125; 运用次注解后，SprimgMVC将会把post或者get请求来的信息进行逆序列化，组成对象，前提是你传过来的值跟该对象匹配。 注意！！使用该注解以后，若想传送非json格式代码，需要指定请求头Content-Type为application/json，否则对象所有属性将为null。","tags":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"https://yangle94.github.io/tags/SpringMVC/"}]},{"title":"Java transient关键字使用记录","date":"2017-02-28T14:01:58.000Z","path":"2017/02/28/Java-transient/","text":"今天对某个对象使用FastJson进行序列化的时候想要把某个属性进行隐藏，找了半天没找到FastJson有什么注解。查询了半天发现谋篇博客有关于transient关键字的介绍，看完突然觉得Java白学了，还有这么一个关键字不知道。 transient的作用及使用方法 我们知道Java中完成对象的序列化需要实现Serilizable接口，实现了该接口则可以进行对象的序列化。然而在实际的开发中，总会有某些属性我们并不想让它进行序列化，可以对此属性加上transient关键字，以后这个属性就不会再被进行序列化和反序列化。当然，这也成为它的局限性，因为没法让序列化、反序列化不同时进行。 样例代码：12345678910111213class User implements Serializable &#123; private transient String passwd; public String getPasswd() &#123; return passwd; &#125; public void setPasswd(String passwd) &#123; this.passwd = passwd; &#125;&#125; transient使用小结 &emsp;&emsp;被transient修饰的变量，如果进行序列化：比如写入到文件中，则此变量就不能再被读取到，会被赋值为null &emsp;&emsp;transient关键字只能修饰成员变量，不能修饰方法和类。如果某个类中需要使用此关键字，必须将该类实现Serilizable接口 &emsp;&emsp;静态变量不论是否被修饰，均不可被序列化。此时注意，虽然再次反序列化以后static变量可能还会有值，此时这个值对应的为当前虚拟机中整个类所对应的值，并非因为将该属性序列化时对此属性进行了序列化。因为static变量为类共有，此属性为类共有，而并非对象私有。","tags":[{"name":"Java","slug":"Java","permalink":"https://yangle94.github.io/tags/Java/"},{"name":"FastJson","slug":"FastJson","permalink":"https://yangle94.github.io/tags/FastJson/"}]},{"title":"Mac上Github的ssh、http的代理","date":"2017-02-25T08:49:42.000Z","path":"2017/02/25/github-ssh-pxory/","text":"因为我们身处天朝外加某堵墙的原因，访问Github实在是不稳定，SSH慢的要死，简直了。现在交给大家利用ShadowScoket进行对Github的加速。 购买一个VPN随便什么VPN都好，我这里用的是TMDVPN，我自己用的也是这个，感觉还不错，也不是很贵，有想要的童鞋请给我发Email：1024920977@qq.com，我买的是50元半年，一个月20G流量，附带邀请码的注册地址。具体使用ShadowScoket的教程他们官网上都有。 设置Git的代理地址 https、https代理如各平台的 Shadowsocks 客户端都提供一个本地的 socks5 代理，那么你可以这样设置，让 Git 通过 HTTP 链接 clone 代码时走 socks5 代理,当然，你需要看看你的ShadowScoket的socks5的监听端口是多少（ShadowScoket里头高级设置有显示）。1234//通过 http 链接 clone 代码时走 socks5 代理git config --global http.proxy \"socks5://127.0.0.1:1086\"//通过 https 链接 clone 代码时走 socks5代理git config --global https.proxy \"socks5://127.0.0.1:1086\" ssh代理上面设置的 HTTP 代理对这种方式 clone 代码是没有影响的，也就是并不会加速，SSH 的代理需要单独设置，其实这个跟 Git 的关系已经不是很大，我们需要改的，是SSH 的配置。在用户目录下建立如下文件 ~/.ssh/config，对 GitHub 的域名做单独的处理123456789 # 这里必须是 github.com，因为这个跟我们 clone 代码时的链接有关Host github.com # 如果用默认端口，这里是 github.com，如果想用443端口，这里就是 ssh.github.com详见 https://help.github.com/articles/using-ssh-over-the-https-port/ HostName github.com User git # 如果是 HTTP 代理，把下面这行取消注释，并把 proxyport 改成自己的 http 代理的端口 # ProxyCommand socat - PROXY:127.0.0.1:%h:%p,proxyport=6667 # 如果是 socks5 代理，则把下面这行取消注释，并把 6666 改成自己 socks5 代理的端口 # ProxyCommand nc -v -x 127.0.0.1:6666 %h %p 整个代理就完成了，以后你要是用http、http和ssh方式访问Github就会走ShadowScoket的socks5的代理，前提是你必须要讲ShadowScoket打开并且链接上vpn服务器，否则，并没有什么卵用。","tags":[{"name":"Github","slug":"Github","permalink":"https://yangle94.github.io/tags/Github/"}]},{"title":"自定义Selenium Grid2 Servlet","date":"2017-02-07T07:45:32.000Z","path":"2017/02/07/SeleniumGridCustomServlet/","text":"最近搞selenium grid的时候需要收集每个时刻selenium gird的监控数据，找了半天好不容易在selenium的官网文档的某个角落找到了办法，特此记录。 官网自定义Sevlet文档 自定义servlet步骤 下载selenium-server-standalone-3.0.1.jar，新建一个java工程并将其当作lib包倒入。 工程下新建一个自定义servlet类，继承org.openqa.grid.web.servlet.RegistryBasedServlet或者javax.servlet.http.HttpServlet.类。RegistryBasedServlet类为selenium grid的核心类，如果你想要获得selenium grid的核心数据，请继承该类。 将此项目导出为一个新jar包，并将其与selenium-server-standalone-3.0.1.jar放在同一个目录下。 再此目录下执行 1java -cp xxx.jar:selenium-server-standalone-3.0.1.jar org.openqa.grid.selenium.GridLauncherV3 -servlets org.openqa.grid.web.servlet.custom.CustomServlet, 若为hub则再加入“-role hub”等其它所需参数。 注意事项java -cp是classpath的意思，意思是将某些jar加入到classpath中，两个jar用：隔开，此时注意在linux下不支持通配符，所以必须手动将名字补全。-servlets后跟的是自定义servlet的地址，GridLauncherV3为main函数所在位置，在3.0以后的selenium-server-standalone.jar中为GridLauncherV3，2.0为GridLauncher。","tags":[{"name":"Selenium Grid","slug":"Selenium-Grid","permalink":"https://yangle94.github.io/tags/Selenium-Grid/"}]},{"title":"docker化selenium grid","date":"2017-02-07T07:08:32.000Z","path":"2017/02/07/docker-selenium/","text":"因为工作需要，本人构建了一个docker化selenium grid，特此记录，以备其它有用的人使用。 1 使用场景调研 完成某个功能的所有操作步骤在同一个页面、session中。 对同一个虚拟机中多个浏览器（多个webdriver、不同用户）之间必须进行浏览器层的cookies隔离，保证相互之间cookies不应相互影响。 对同一个虚拟机中多个浏览器（多个webdriver、不同用户）进行模拟键盘输入时，保证所有键盘操作必须相互隔离，保证对应的模拟键盘输入进入其对应的输入框内。 对所有请求进行调度排序。 设定超时时间，对超过时间限制的请求进行删除，保证资源的释放。 对各个selenium节点有对应功能性监控（比如某个节点是否空闲等）。 各个selenium节点对应的日志查看问题。 2 Docker化Selenium Grid2还存在的问题 Windows对docker提供的镜像分别为nanoServer和windowsservercore，但其中并不存在GUI、IE等所需内容，查阅官方资料，官方人员说明目前项目并不支持GUI操作。详见关于docker产品经理对于Windows GUI的说明。 目前对于windows镜像需要人为的干预。目前我所采用的方式是为单独建立windows的虚拟机，在虚拟机上对重新部署selenium。在对含有插件的页面进行访问时，需要提前将插件安装好，也就是说需要提前对docker file进行构建。 3 整体构建图4 各个node节点的功能性监控 在selenium grid的hub节点中自带了一个监控页面，用于监控每个节点的运行情况、ip端口信息，包括有多少任务在排队中当前总共有多少任务在运行等，此页面访问地址为selenium hub节点的4444端口。 5 部署步骤 部署selenium hub1docker run -d -p 4444:4444 –name registry.cn-hangzhou.aliyuncs.com/angle/selenium-hub:2.1 部署chrome1docker run -d -P -p 5900:5900 –link selenium-hub:hub –name chrome registry.cn-hangzhou.aliyuncs.com/angle/node-chrome-debug:2.1 部署firefox1docker run -d -P -p 5901:5900 –link selenium-hub:hub –name firefox registry.cn-hangzhou.aliyuncs.com/angle/node-firefox-debug:2.1 部署IEnodeconfig.json12345678910111213141516171819202122232425&#123;“capabilities”: [ &#123; “browserName”: “internet explorer”, “maxInstances”: 3, “seleniumProtocol”: “WebDriver” &#125; ],“proxy”: “org.openqa.grid.selenium.proxy.DefaultRemoteProxy”,“maxSession”: 3,“port”: 5555,“register”: true,“registerCycle”: 5000,“hub”: “http://localhost:4444“,“nodeStatusCheckTimeout”: 5000,“nodePolling”: 5000,“role”: “node”,“unregisterIfStillDownAfter”: 60000,“downPollingLimit”: 2,“debug”: false,“servlets” : [],“withoutServlets”: [],“custom”: &#123;&#125;&#125; 下载selenium-server-standalone-3.0.1.jar 下载地址：https://selenium-release.storage.googleapis.com/3.0/selenium-server-standalone-3.0.1.jar 部署命令1java -jar selenium-server-standalone.jar -role node -nodeConfig nodeconfig.json 6 已解决的问题我所用的原始Selenium Grid Docker镜像中有中文乱码问题，需要在docker file中加入字符集解决。Selenium Grid中存在监控功能并不完善，若想要获取此类信息数据，需要加入自定义servlet（关于此章我会在另一片文章中介绍） 7 下载以及中文适配由于selenium官方的docker镜像对于中文兼容性不是很好，会出现某些中文乱码的问题，其实是因为其包含的乌班图镜像中缺少了部分字符集的原因，为了修复这个问题，我特意制作了修复了此问题的镜像并上传到了阿里云镜像服务器（代码中已经替换）。","tags":[{"name":"Selenium Grid","slug":"Selenium-Grid","permalink":"https://yangle94.github.io/tags/Selenium-Grid/"},{"name":"Docker","slug":"Docker","permalink":"https://yangle94.github.io/tags/Docker/"}]},{"title":"java内部类实现原理以及注意事项","date":"2016-12-28T07:08:32.000Z","path":"2016/12/28/innerClass/","text":"1.什么是内部类：定义在某个类中的类叫做内部类。 2.内部类有什么好处：1）内部类方法可以访问类定义所在的做哦用语中的数据，包括私有数据。2）内部类可以对同一个包中的其他类隐藏起来。3）当想要定义一个回调函数且又不想编写大量代码的时候，使用匿名内部类比较便捷。 3.内部类实现原理代码样例:12345678910111213141516171819class TalkingClock &#123; private int interval; private boolean beep; public TalkingClock(int interval, boolean beep) &#123; this.interval = interval; this.beep = beep; &#125; public void start() &#123; ActionListener listener = new TimePrinter(); Time t = new Time(interval,listener); t.start(); &#125; public class TimePrinter implements ActionListener &#123; public void actionPerformed(ActionEvent event) &#123; Date now = new Date(); if(beep) Toolkit.getDefaultToolkit().beep(); &#125; &#125;&#125; 解释:首先，内部类是一种编译器现象，与java虚拟机无关。也就是说，在虚拟机中，类并不存在内部类一说。在上面两个类中，TimePrinterl类是TalkingClock的内部类，当java编译器对此两个类进行编译时，会将内部类TimePrinter编译为TalkingClock$TimePrinter，并在内部类中增加一条外部类的引用，以此来访问外部类对象中的域，并会修改其无参的构造方法为有参的构造方法（增加一个TalkingClock参数），对于外部类TalkingClock，会增加一个static boolean access$0(TalkingClock)方法，具体可以使用java -private innerClass.TalkingClock$TimePrinter(由于在linux等系统的shell中$为关键字，所以此时需要转义)查看。 123456789101112public class TalkingClock$TimePrinter &#123; public TalkingClock$TimePrinter(TalkingClock); public void actionPerformed(java.awt.event.ActionEvent); final TalkingClock this$0;&#125;class TalkingClock &#123; private int interval; private boolean beep; public TalkingClock(int interval, boolean beep); public void start(); static boolean access$0(TalkingClock);&#125; 由此，当内部类中需要访问外部类的私有成员时，内部类可以调用外部类的静态方法进行对私有成员的访问。当然，access$0并不是一个合法的java方法名，因此，在java层面调用此方法名并不现实。但可以用底层的其他方法进行对此方法的调用。","tags":[{"name":"Java","slug":"Java","permalink":"https://yangle94.github.io/tags/Java/"}]},{"title":"jq的ajax请求后台未出错却进入error问题","date":"2016-12-27T07:08:32.000Z","path":"2016/12/27/jqAjaxResError/","text":"现象:1234567891011121314jq进行ajax请求，后端并为报错，状态码为200但ajax请求进入error方法。 $.ajax(&#123; url : \"http:/www.baidu.com\", data : &#123; param : \"param\" &#125; dataType : \"json\", success : function(data) &#123; alert(\"返回成功，进入成功方法\"); &#125; error : function() &#123; alert(\"返回失败，进入失败方法\") &#125; &#125;) 检查思路:1.查看后端日志，发现后端并未报错。2.打开谷歌浏览器调试模式，发现状态吗为200。 由此可推断出后台并为发生任何异常，判断并不是因为后端错误所导致。由此可以判断能够接触到返回数据并出现错误的只能是js部分。 最终结果查询资料后发现，对于ajax请求如果规定了返回值的格式（dataType），则返回值一定要符合dataType的格式。若返回的格式跟dataType的格式不相符，js会在解析的时候报错，由此进入了error的方法。后端以前返回值为”success”，将其改为{“isSuccess” : “success”}后进行返回，程序运行成功，进入ajax的success方法。由此可见，若规定了dataType以后，后端返回的数据必须符合此格式，否则，前端js在解析的时候会发生错误。","tags":[{"name":"ajax","slug":"ajax","permalink":"https://yangle94.github.io/tags/ajax/"},{"name":"jq","slug":"jq","permalink":"https://yangle94.github.io/tags/jq/"}]},{"title":"开博了～","date":"2016-12-25T07:08:32.000Z","path":"2016/12/25/index/","text":"哈哈，功夫不负有心人，终于在github page上开了自己的博客，顿时兴奋无比。 本站主要是用在我个人写的一些程序中遇到的问题。本人初出茅庐，希望大家能够不吝赐教。本次仅仅是为了测试搭成的框架是否可以运行，稍后会写一个博客的搭建教程。","tags":[{"name":"other","slug":"other","permalink":"https://yangle94.github.io/tags/other/"}]}]