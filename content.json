[{"title":"swagger-ui注解","date":"2017-03-14T02:30:50.000Z","path":"2017/03/14/swagger-annotation/","text":"今天使用swagger的时候出现了不少一点问题，body传上来的Json字符串在swagger-ui上的形式总是不符合我的意愿，我找了好久才找到了问题。特别来记录一下。 @Api用在类上，说明该类的作用 @ApiOperation用在方法上，说明方法的作用 @ApiImplicitParams、@ApiImplicitParam用在方法上包含一组参数说明用在@ApiImplicitParams注解中，指定一个请求参数的各个方面paramType:参数放在哪个地方header–&gt;请求参数的获取：@RequestHeaderquery–&gt;请求参数的获取：@RequestParampath（用于restful接口）–&gt;请求参数的获取：@PathVariablebody（不常用）form（不常用）name：参数名dataType：参数类型required：参数是否必须传value：参数的意思defaultValue：参数的默认值 @ApiResponses用于表示一组响应 @ApiResponse用在@ApiResponses中，一般用于表达一个错误的响应信息code：数字，例如400message：信息，例如”请求参数没填好”response：抛出异常的类 @ApiModel描述一个Model的信息（这种一般用在post创建的时候，使用@RequestBody这样的场景，请求参数无法使用@ApiImplicitParam注解进行描述的时候） @ApiModelProperty描述一个model的属性","tags":[{"name":"swagger-ui","slug":"swagger-ui","permalink":"https://yangle94.github.io/tags/swagger-ui/"}]},{"title":"maven上传文件到私库","date":"2017-03-08T03:14:14.000Z","path":"2017/03/08/maven-uploadJar/","text":"今天因为在服务器端对webp进行格式转换，发现对于webp的jar在maven的仓库里并没有发现。于是只好自己把webp的jar加入了maven私服。将代码进行copy，以备不时之需。12345发布到本地仓库：mvn install:install-file -DgroupId=[groupId] -DartifactId=[artifactId] -Dversion=[version] -Dpackaging=jar -Dfile=[path to file] 发布到Nexus仓库：mvn deploy:deploy-file -DgroupId==[groupId] -DartifactId=[artifactId] -Dversion=[version] -Dpackaging=jar -Dfile=[path to file] -Durl=[url] -DrepositoryId=[id]","tags":[{"name":"maven","slug":"maven","permalink":"https://yangle94.github.io/tags/maven/"}]},{"title":"带有资源的try语句（AutoCloseable）","date":"2017-03-08T01:45:02.000Z","path":"2017/03/08/AutoCloseable-Interface/","text":"今天在关闭输入输出流的时候，觉得总是手动去关闭太麻烦，有没有什么简单的方法。于是乎发现了AutoCloseable这个接口。 重申一下为什么要手动关闭输入输出流对于平常的Java对象来说，如果Java的gc机制发现某个对象已经不可到达，就会启动对此对象的内存回收机制。当然，他什么时候能够把对象回收完了，是根据操作系统的调度来决定的，并不是说gc机制一起动，就能立刻回收此对象的内存。但是对于InputStream和OutputStream以及他们的子类来说，如果开启了某个流，就会有操作系统之外的资源依附在某个Java对象上，这就导致gc认为其实活着的，而不是死亡的，所以并不能出发gc机制。 AutoCloseable接口在Java1.7中提供了新的AutoCloseable接口，以前的Closeable接口扩展了AutoCloseable接口，也就是说，所有的实现了Closeable接口的输入输出流全部实现了AutoCloseable接口，就是说所有的输入输出流都能进行带资源的try catch语句。 12345678910public class InputStreamReaderTest &#123; public static void main(String[] args) &#123; try(BufferedReader reader = new BufferedReader(new InputStreamReader( new FileInputStream(new File(\"/home/angle/test.webp\")),\"UTF8\"),1024))&#123; System.out.println(reader.readLine()); //这里直接读一行 &#125;catch(IOException e)&#123; e.printStackTrace(); &#125; &#125;&#125; 此时，就不需要我们自己手动去关闭输入、输出流了，带资源的try块儿会帮我们把资源管理好。 注：关于带资源的try语句的3个关键点：由带资源的try语句管理的资源必须是实现了AutoCloseable接口的类的对象。 在try代码中声明的资源被隐式声明为fianl。 通过使用分号分隔每个声明可以管理多个资源。","tags":[{"name":"Java","slug":"Java","permalink":"https://yangle94.github.io/tags/Java/"},{"name":"AutoCloseable","slug":"AutoCloseable","permalink":"https://yangle94.github.io/tags/AutoCloseable/"}]},{"title":"考虑用静态工厂方法替代构造函数","date":"2017-03-02T14:04:54.000Z","path":"2017/03/02/staticFactory/","text":"静态工厂方法优点 静态工厂方法有名称，根据名称可以做到见文知意。对于构造方法而言，由于方法签名的原因，一个类只可能一种相同的方法签名，当然，可以通过参数顺序来克服这个问题，但是，相同参数容易让人混乱，而且有可能错过了编译器的异常。 静态工厂方法可以不必每次调用它的时候都创建一个新的对象。 可以返回原返回类型的任何子类型对象。1234567891011121314151617181920212223242526272829303132333435363738public interface Service&#123; //do something&#125;public interface Provider&#123; Service newService();&#125;public class Service &#123; //不允许外部实例化 private Service()&#123;&#125;; private static final Map&lt;String,Provider&gt; providers = new ConcurrentHashMap&lt;&gt;(); public static final String defKey = \"&lt;def&gt;\"; //注册 public static void registerDefaultProvider(Provider provider) &#123; registerProvider(defKey, provider); &#125; public static void registerDefaultProvider(String name, Provider provider) &#123; providers.put(name, provider); &#125; //获取 public static Service newInstance() &#123; return newInstance(defkey); &#125; public static Service newInstance(String name) &#123; Provider p = providers.get(name); if(null == p) throw new IlleaglArgumentException(\"No provider registered with name : \" + name); return p.newService(); &#125;&#125; 缺点: 类如果不含有公有或者受保护的构造方法，就不能被子类化。因祸得福的是，我们鼓励复合，而不是继承。 静态工厂方法与普通静态方法没有任何区别，“赶着一等公民（构造方法）的活儿，却享受不到一等公民的待遇（Javadoc等工具并不关注静态工厂方法) 何时应该用静态工厂方法 如果需要大量含有共同签名的构造方法的时候。 每次返回的对象是不可变类的时候，可以提前构造好对象供其使用。 需要返回不同的子类的时候。 静态工厂方法命名 valueOf —- 返回值与参数具有相同的值 of —- valueOf的替代 geteInstance —- 通过参数描述返回实例，但是值不一定相同 newInstance —- 创建一个新的对象 getType —- Type表示返回的实例的类型 newType —- 返回一个新的实例","tags":[{"name":"JAVA","slug":"JAVA","permalink":"https://yangle94.github.io/tags/JAVA/"}]},{"title":"SpringMVC_Annotation_@RequestBody","date":"2017-03-01T11:33:40.000Z","path":"2017/03/01/SpringMVC-Annotation-RequestBody/","text":"@RequestBody注解的源码123456@Target(&#123;ElementType.PARAMETER&#125;)@Retention(RetentionPolicy.RUNTIME)@Documentedpublic @interface RequestBody &#123; boolean required() default true;&#125; 由源码可见，@RequestBody只有一个required属性，默认值为true，该注解会保留至.class文件中，利用反射可以进行查找。 @RequestBody的作用该注解常用来处理Content-Type: 不是application/x-www-form-urlencoded编码的内容，例如application/json, application/xml等； 它是通过使用HandlerAdapter 配置的HttpMessageConverters来解析post data body，然后绑定到相应的bean上的。 因为配置有FormHttpMessageConverter，所以也可以用来处理 application/x-www-form-urlencoded的内容，处理完的结果放在一个MultiValueMap里，这种情况在某些特殊需求下使用，详情查看FormHttpMessageConverter api; 例如1234@RequestMapping(value = \"sendMessage\", method = RequestMethod.POST)public String sendMesscage(@RequestBody UserIdCodeDTO userIdCodeMessageDTO) &#123; return userIdCodeMessageDTO.toString();&#125; 运用次注解后，SprimgMVC将会把post或者get请求来的信息进行逆序列化，组成对象，前提是你传过来的值跟该对象匹配。 注意！！使用该注解以后，若想传送非json格式代码，需要指定请求头Content-Type为application/json，否则对象所有属性将为null。","tags":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"https://yangle94.github.io/tags/SpringMVC/"}]},{"title":"Java transient关键字使用记录","date":"2017-02-28T14:01:58.000Z","path":"2017/02/28/Java-transient/","text":"今天对某个对象使用FastJson进行序列化的时候想要把某个属性进行隐藏，找了半天没找到FastJson有什么注解。查询了半天发现谋篇博客有关于transient关键字的介绍，看完突然觉得Java白学了，还有这么一个关键字不知道。 transient的作用及使用方法 我们知道Java中完成对象的序列化需要实现Serilizable接口，实现了该接口则可以进行对象的序列化。然而在实际的开发中，总会有某些属性我们并不想让它进行序列化，可以对此属性加上transient关键字，以后这个属性就不会再被进行序列化和反序列化。当然，这也成为它的局限性，因为没法让序列化、反序列化不同时进行。 样例代码：12345678910111213class User implements Serializable &#123; private transient String passwd; public String getPasswd() &#123; return passwd; &#125; public void setPasswd(String passwd) &#123; this.passwd = passwd; &#125;&#125; transient使用小结 &emsp;&emsp;被transient修饰的变量，如果进行序列化：比如写入到文件中，则此变量就不能再被读取到，会被赋值为null &emsp;&emsp;transient关键字只能修饰成员变量，不能修饰方法和类。如果某个类中需要使用此关键字，必须将该类实现Serilizable接口 &emsp;&emsp;静态变量不论是否被修饰，均不可被序列化。此时注意，虽然再次反序列化以后static变量可能还会有值，此时这个值对应的为当前虚拟机中整个类所对应的值，并非因为将该属性序列化时对此属性进行了序列化。因为static变量为类共有，此属性为类共有，而并非对象私有。","tags":[{"name":"Java","slug":"Java","permalink":"https://yangle94.github.io/tags/Java/"},{"name":"FastJson","slug":"FastJson","permalink":"https://yangle94.github.io/tags/FastJson/"}]},{"title":"Mac上Github的ssh、http的代理","date":"2017-02-25T08:49:42.000Z","path":"2017/02/25/github-ssh-pxory/","text":"因为我们身处天朝外加某堵墙的原因，访问Github实在是不稳定，SSH慢的要死，简直了。现在交给大家利用ShadowScoket进行对Github的加速。 购买一个VPN随便什么VPN都好，我这里用的是TMDVPN，我自己用的也是这个，感觉还不错，也不是很贵，有想要的童鞋请给我发Email：1024920977@qq.com，我买的是50元半年，一个月20G流量，附带邀请码的注册地址。具体使用ShadowScoket的教程他们官网上都有。 设置Git的代理地址https、https代理如各平台的 Shadowsocks 客户端都提供一个本地的 socks5 代理，那么你可以这样设置，让 Git 通过 HTTP 链接 clone 代码时走 socks5 代理,当然，你需要看看你的ShadowScoket的socks5的监听端口是多少（ShadowScoket里头高级设置有显示）。1234//通过 http 链接 clone 代码时走 socks5 代理git config --global http.proxy \"socks5://127.0.0.1:1086\"//通过 https 链接 clone 代码时走 socks5代理git config --global https.proxy \"socks5://127.0.0.1:1086\" ssh代理上面设置的 HTTP 代理对这种方式 clone 代码是没有影响的，也就是并不会加速，SSH 的代理需要单独设置，其实这个跟 Git 的关系已经不是很大，我们需要改的，是SSH 的配置。在用户目录下建立如下文件 ~/.ssh/config，对 GitHub 的域名做单独的处理123456789 # 这里必须是 github.com，因为这个跟我们 clone 代码时的链接有关Host github.com # 如果用默认端口，这里是 github.com，如果想用443端口，这里就是 ssh.github.com详见 https://help.github.com/articles/using-ssh-over-the-https-port/ HostName github.com User git # 如果是 HTTP 代理，把下面这行取消注释，并把 proxyport 改成自己的 http 代理的端口 # ProxyCommand socat - PROXY:127.0.0.1:%h:%p,proxyport=6667 # 如果是 socks5 代理，则把下面这行取消注释，并把 6666 改成自己 socks5 代理的端口 # ProxyCommand nc -v -x 127.0.0.1:6666 %h %p 整个代理就完成了，以后你要是用http、http和ssh方式访问Github就会走ShadowScoket的socks5的代理，前提是你必须要讲ShadowScoket打开并且链接上vpn服务器，否则，并没有什么卵用。","tags":[{"name":"Github","slug":"Github","permalink":"https://yangle94.github.io/tags/Github/"}]},{"title":"自定义Selenium Grid2 Servlet","date":"2017-02-07T07:45:32.000Z","path":"2017/02/07/SeleniumGridCustomServlet/","text":"最近搞selenium grid的时候需要收集每个时刻selenium gird的监控数据，找了半天好不容易在selenium的官网文档的某个角落找到了办法，特此记录。 官网自定义Sevlet文档 自定义servlet步骤 下载selenium-server-standalone-3.0.1.jar，新建一个java工程并将其当作lib包倒入。 工程下新建一个自定义servlet类，继承org.openqa.grid.web.servlet.RegistryBasedServlet或者javax.servlet.http.HttpServlet.类。RegistryBasedServlet类为selenium grid的核心类，如果你想要获得selenium grid的核心数据，请继承该类。 将此项目导出为一个新jar包，并将其与selenium-server-standalone-3.0.1.jar放在同一个目录下。 再此目录下执行 1java -cp xxx.jar:selenium-server-standalone-3.0.1.jar org.openqa.grid.selenium.GridLauncherV3 -servlets org.openqa.grid.web.servlet.custom.CustomServlet, 若为hub则再加入“-role hub”等其它所需参数。 注意事项java -cp是classpath的意思，意思是将某些jar加入到classpath中，两个jar用：隔开，此时注意在linux下不支持通配符，所以必须手动将名字补全。-servlets后跟的是自定义servlet的地址，GridLauncherV3为main函数所在位置，在3.0以后的selenium-server-standalone.jar中为GridLauncherV3，2.0为GridLauncher。","tags":[{"name":"Selenium Grid","slug":"Selenium-Grid","permalink":"https://yangle94.github.io/tags/Selenium-Grid/"}]},{"title":"docker化selenium grid","date":"2017-02-07T07:08:32.000Z","path":"2017/02/07/docker-selenium/","text":"因为工作需要，本人构建了一个docker化selenium grid，特此记录，以备其它有用的人使用。 1 使用场景调研 完成某个功能的所有操作步骤在同一个页面、session中。 对同一个虚拟机中多个浏览器（多个webdriver、不同用户）之间必须进行浏览器层的cookies隔离，保证相互之间cookies不应相互影响。 对同一个虚拟机中多个浏览器（多个webdriver、不同用户）进行模拟键盘输入时，保证所有键盘操作必须相互隔离，保证对应的模拟键盘输入进入其对应的输入框内。 对所有请求进行调度排序。 设定超时时间，对超过时间限制的请求进行删除，保证资源的释放。 对各个selenium节点有对应功能性监控（比如某个节点是否空闲等）。 各个selenium节点对应的日志查看问题。 2 Docker化Selenium Grid2还存在的问题 Windows对docker提供的镜像分别为nanoServer和windowsservercore，但其中并不存在GUI、IE等所需内容，查阅官方资料，官方人员说明目前项目并不支持GUI操作。详见关于docker产品经理对于Windows GUI的说明。 目前对于windows镜像需要人为的干预。目前我所采用的方式是为单独建立windows的虚拟机，在虚拟机上对重新部署selenium。在对含有插件的页面进行访问时，需要提前将插件安装好，也就是说需要提前对docker file进行构建。 3 整体构建图4 各个node节点的功能性监控 在selenium grid的hub节点中自带了一个监控页面，用于监控每个节点的运行情况、ip端口信息，包括有多少任务在排队中当前总共有多少任务在运行等，此页面访问地址为selenium hub节点的4444端口。 5 部署步骤 部署selenium hub1docker run -d -p 4444:4444 –name selenium-hub angley/selenium-hub:1.1 部署chrome12docker run -d -P -p 5900:5900 –link selenium-hub:hub –name chrome angley/node-chrome-debug:1.0 部署firefox1docker run -d -P -p 5901:5900 –link selenium-hub:hub –name firefox angley/node-firefox-debug:1.0 部署IEnodeconfig.json12345678910111213141516171819202122232425&#123;“capabilities”: [ &#123; “browserName”: “internet explorer”, “maxInstances”: 3, “seleniumProtocol”: “WebDriver” &#125; ],“proxy”: “org.openqa.grid.selenium.proxy.DefaultRemoteProxy”,“maxSession”: 3,“port”: 5555,“register”: true,“registerCycle”: 5000,“hub”: “http://localhost:4444“,“nodeStatusCheckTimeout”: 5000,“nodePolling”: 5000,“role”: “node”,“unregisterIfStillDownAfter”: 60000,“downPollingLimit”: 2,“debug”: false,“servlets” : [],“withoutServlets”: [],“custom”: &#123;&#125;&#125; 下载selenium-server-standalone-3.0.1.jar 下载地址：https://selenium-release.storage.googleapis.com/3.0/selenium-server-standalone-3.0.1.jar 部署命令1java -jar selenium-server-standalone.jar -role node -nodeConfig nodeconfig.json 6 已解决的问题我所用的原始Selenium Grid Docker镜像中有中文乱码问题，需要在docker file中加入字符集解决。Selenium Grid中存在监控功能并不完善，若想要获取此类信息数据，需要加入自定义servlet（关于此章我会在另一片文章中介绍）","tags":[{"name":"Selenium Grid","slug":"Selenium-Grid","permalink":"https://yangle94.github.io/tags/Selenium-Grid/"},{"name":"Docker","slug":"Docker","permalink":"https://yangle94.github.io/tags/Docker/"}]},{"title":"java内部类实现原理以及注意事项","date":"2016-12-28T07:08:32.000Z","path":"2016/12/28/innerClass/","text":"1.什么是内部类：定义在某个类中的类叫做内部类。 2.内部类有什么好处：1）内部类方法可以访问类定义所在的做哦用语中的数据，包括私有数据。2）内部类可以对同一个包中的其他类隐藏起来。3）当想要定义一个回调函数且又不想编写大量代码的时候，使用匿名内部类比较便捷。 3.内部类实现原理代码样例:12345678910111213141516171819class TalkingClock &#123; private int interval; private boolean beep; public TalkingClock(int interval, boolean beep) &#123; this.interval = interval; this.beep = beep; &#125; public void start() &#123; ActionListener listener = new TimePrinter(); Time t = new Time(interval,listener); t.start(); &#125; public class TimePrinter implements ActionListener &#123; public void actionPerformed(ActionEvent event) &#123; Date now = new Date(); if(beep) Toolkit.getDefaultToolkit().beep(); &#125; &#125;&#125; 解释:首先，内部类是一种编译器现象，与java虚拟机无关。也就是说，在虚拟机中，类并不存在内部类一说。在上面两个类中，TimePrinterl类是TalkingClock的内部类，当java编译器对此两个类进行编译时，会将内部类TimePrinter编译为TalkingClock$TimePrinter，并在内部类中增加一条外部类的引用，以此来访问外部类对象中的域，并会修改其无参的构造方法为有参的构造方法（增加一个TalkingClock参数），对于外部类TalkingClock，会增加一个static boolean access$0(TalkingClock)方法，具体可以使用java -private innerClass.TalkingClock$TimePrinter(由于在linux等系统的shell中$为关键字，所以此时需要转义)查看。 123456789101112public class TalkingClock$TimePrinter &#123; public TalkingClock$TimePrinter(TalkingClock); public void actionPerformed(java.awt.event.ActionEvent); final TalkingClock this$0;&#125;class TalkingClock &#123; private int interval; private boolean beep; public TalkingClock(int interval, boolean beep); public void start(); static boolean access$0(TalkingClock);&#125; 由此，当内部类中需要访问外部类的私有成员时，内部类可以调用外部类的静态方法进行对私有成员的访问。当然，access$0并不是一个合法的java方法名，因此，在java层面调用此方法名并不现实。但可以用底层的其他方法进行对此方法的调用。","tags":[{"name":"Java","slug":"Java","permalink":"https://yangle94.github.io/tags/Java/"}]},{"title":"jq的ajax请求后台未出错却进入error问题","date":"2016-12-27T07:08:32.000Z","path":"2016/12/27/jqAjaxResError/","text":"现象:1234567891011121314jq进行ajax请求，后端并为报错，状态码为200但ajax请求进入error方法。 $.ajax(&#123; url : \"http:/www.baidu.com\", data : &#123; param : \"param\" &#125; dataType : \"json\", success : function(data) &#123; alert(\"返回成功，进入成功方法\"); &#125; error : function() &#123; alert(\"返回失败，进入失败方法\") &#125; &#125;) 检查思路:1.查看后端日志，发现后端并未报错。2.打开谷歌浏览器调试模式，发现状态吗为200。 由此可推断出后台并为发生任何异常，判断并不是因为后端错误所导致。由此可以判断能够接触到返回数据并出现错误的只能是js部分。 最终结果查询资料后发现，对于ajax请求如果规定了返回值的格式（dataType），则返回值一定要符合dataType的格式。若返回的格式跟dataType的格式不相符，js会在解析的时候报错，由此进入了error的方法。后端以前返回值为”success”，将其改为{“isSuccess” : “success”}后进行返回，程序运行成功，进入ajax的success方法。由此可见，若规定了dataType以后，后端返回的数据必须符合此格式，否则，前端js在解析的时候会发生错误。","tags":[{"name":"ajax","slug":"ajax","permalink":"https://yangle94.github.io/tags/ajax/"},{"name":"jq","slug":"jq","permalink":"https://yangle94.github.io/tags/jq/"}]},{"title":"开博了～","date":"2016-12-25T07:08:32.000Z","path":"2016/12/25/index/","text":"哈哈，功夫不负有心人，终于在github page上开了自己的博客，顿时兴奋无比。 本站主要是用在我个人写的一些程序中遇到的问题。本人初出茅庐，希望大家能够不吝赐教。本次仅仅是为了测试搭成的框架是否可以运行，稍后会写一个博客的搭建教程。","tags":[{"name":"other","slug":"other","permalink":"https://yangle94.github.io/tags/other/"}]}]