[{"title":"Java transient关键字使用记录","date":"2017-02-28T14:01:58.000Z","path":"2017/02/28/Java-transient/","text":"今天对某个对象使用FastJson进行序列化的时候想要把某个属性进行隐藏，找了半天没找到FastJson有什么注解。查询了半天发现谋篇博客有关于transient关键字的介绍，看完突然觉得Java白学了，还有这么一个关键字不知道。 transient的作用及使用方法 我们知道Java中完成对象的序列化需要实现Serilizable接口，实现了该接口则可以进行对象的序列化。然而在实际的开发中，总会有某些属性我们并不想让它进行序列化，可以对此属性加上transient关键字，以后这个属性就不会再被进行序列化和反序列化。当然，这也成为它的局限性，因为没法让序列化、反序列化不同时进行。 样例代码：12345678910111213class User implements Serializable &#123; private transient String passwd; public String getPasswd() &#123; return passwd; &#125; public void setPasswd(String passwd) &#123; this.passwd = passwd; &#125;&#125; transient使用小结 被transient修饰的变量，如果进行序列化：比如写入到文件中，则此变量就不能再被读取到，会被 赋值为null transient关键字只能修饰成员变量，不能修饰方法和类。如果某个类中需要使用此关键字，必须将 该类实现Serilizable接口 静态变量不论是否被修饰，均不可被序列化。此时注意，虽然再次反序列化以后static变量可能还会有值，此时这个值对应的为当前虚拟机中整个类所对应的值，并非因为将该属性序列化时对此属性进行了序列化。因为static变量为类共有，此属性为类共有，而并非对象私有。","tags":[{"name":"Java","slug":"Java","permalink":"https://yangle94.github.io/tags/Java/"},{"name":"FastJson","slug":"FastJson","permalink":"https://yangle94.github.io/tags/FastJson/"}]},{"title":"Mac上Github的ssh、http的代理","date":"2017-02-25T08:49:42.000Z","path":"2017/02/25/github-ssh-pxory/","text":"因为我们身处天朝外加某堵墙的原因，访问Github实在是不稳定，SSH慢的要死，简直了。现在交给大家利用ShadowScoket进行对Github的加速。 购买一个VPN随便什么VPN都好，我这里用的是TMDVPN，我自己用的也是这个，感觉还不错，也不是很贵，有想要的童鞋请给我发Email：1024920977@qq.com，我买的是50元半年，一个月20G流量，附带邀请码的注册地址。具体使用ShadowScoket的教程他们官网上都有。 设置Git的代理地址https、https代理如各平台的 Shadowsocks 客户端都提供一个本地的 socks5 代理，那么你可以这样设置，让 Git 通过 HTTP 链接 clone 代码时走 socks5 代理,当然，你需要看看你的ShadowScoket的socks5的监听端口是多少（ShadowScoket里头高级设置有显示）。1234//通过 http 链接 clone 代码时走 socks5 代理git config --global http.proxy \"socks5://127.0.0.1:1086\"//通过 https 链接 clone 代码时走 socks5代理git config --global https.proxy \"socks5://127.0.0.1:1086\" ssh代理上面设置的 HTTP 代理对这种方式 clone 代码是没有影响的，也就是并不会加速，SSH 的代理需要单独设置，其实这个跟 Git 的关系已经不是很大，我们需要改的，是SSH 的配置。在用户目录下建立如下文件 ~/.ssh/config，对 GitHub 的域名做单独的处理123456789 # 这里必须是 github.com，因为这个跟我们 clone 代码时的链接有关Host github.com # 如果用默认端口，这里是 github.com，如果想用443端口，这里就是 ssh.github.com详见 https://help.github.com/articles/using-ssh-over-the-https-port/ HostName github.com User git # 如果是 HTTP 代理，把下面这行取消注释，并把 proxyport 改成自己的 http 代理的端口 # ProxyCommand socat - PROXY:127.0.0.1:%h:%p,proxyport=6667 # 如果是 socks5 代理，则把下面这行取消注释，并把 6666 改成自己 socks5 代理的端口 # ProxyCommand nc -v -x 127.0.0.1:6666 %h %p 整个代理就完成了，以后你要是用http、http和ssh方式访问Github就会走ShadowScoket的socks5的代理，前提是你必须要讲ShadowScoket打开并且链接上vpn服务器，否则，并没有什么卵用。","tags":[{"name":"Github","slug":"Github","permalink":"https://yangle94.github.io/tags/Github/"}]},{"title":"自定义Selenium Grid2 Servlet","date":"2017-02-07T07:45:32.000Z","path":"2017/02/07/SeleniumGridCustomServlet/","text":"最近搞selenium grid的时候需要收集每个时刻selenium gird的监控数据，找了半天好不容易在selenium的官网文档的某个角落找到了办法，特此记录。 官网自定义Sevlet文档 自定义servlet步骤 下载selenium-server-standalone-3.0.1.jar，新建一个java工程并将其当作lib包倒入。 工程下新建一个自定义servlet类，继承org.openqa.grid.web.servlet.RegistryBasedServlet或者javax.servlet.http.HttpServlet.类。RegistryBasedServlet类为selenium grid的核心类，如果你想要获得selenium grid的核心数据，请继承该类。 将此项目导出为一个新jar包，并将其与selenium-server-standalone-3.0.1.jar放在同一个目录下。 再此目录下执行 1java -cp xxx.jar:selenium-server-standalone-3.0.1.jar org.openqa.grid.selenium.GridLauncherV3 -servlets org.openqa.grid.web.servlet.custom.CustomServlet, 若为hub则再加入“-role hub”等其它所需参数。 注意事项java -cp是classpath的意思，意思是将某些jar加入到classpath中，两个jar用：隔开，此时注意在linux下不支持通配符，所以必须手动将名字补全。-servlets后跟的是自定义servlet的地址，GridLauncherV3为main函数所在位置，在3.0以后的selenium-server-standalone.jar中为GridLauncherV3，2.0为GridLauncher。","tags":[{"name":"Selenium Grid","slug":"Selenium-Grid","permalink":"https://yangle94.github.io/tags/Selenium-Grid/"}]},{"title":"docker化selenium grid","date":"2017-02-07T07:08:32.000Z","path":"2017/02/07/docker-selenium/","text":"因为工作需要，本人构建了一个docker化selenium grid，特此记录，以备其它有用的人使用。 1 使用场景调研 完成某个功能的所有操作步骤在同一个页面、session中。 对同一个虚拟机中多个浏览器（多个webdriver、不同用户）之间必须进行浏览器层的cookies隔离，保证相互之间cookies不应相互影响。 对同一个虚拟机中多个浏览器（多个webdriver、不同用户）进行模拟键盘输入时，保证所有键盘操作必须相互隔离，保证对应的模拟键盘输入进入其对应的输入框内。 对所有请求进行调度排序。 设定超时时间，对超过时间限制的请求进行删除，保证资源的释放。 对各个selenium节点有对应功能性监控（比如某个节点是否空闲等）。 各个selenium节点对应的日志查看问题。 2 Docker化Selenium Grid2还存在的问题 Windows对docker提供的镜像分别为nanoServer和windowsservercore，但其中并不存在GUI、IE等所需内容，查阅官方资料，官方人员说明目前项目并不支持GUI操作。详见关于docker产品经理对于Windows GUI的说明。 目前对于windows镜像需要人为的干预。目前我所采用的方式是为单独建立windows的虚拟机，在虚拟机上对重新部署selenium。在对含有插件的页面进行访问时，需要提前将插件安装好，也就是说需要提前对docker file进行构建。 3 整体构建图4 各个node节点的功能性监控 在selenium grid的hub节点中自带了一个监控页面，用于监控每个节点的运行情况、ip端口信息，包括有多少任务在排队中当前总共有多少任务在运行等，此页面访问地址为selenium hub节点的4444端口。 5 部署步骤 部署selenium hub1docker run -d -p 4444:4444 –name selenium-hub angley/selenium-hub:1.1 部署chrome12docker run -d -P -p 5900:5900 –link selenium-hub:hub –name chrome angley/node-chrome-debug:1.0 部署firefox1docker run -d -P -p 5901:5900 –link selenium-hub:hub –name firefox angley/node-firefox-debug:1.0 部署IEnodeconfig.json12345678910111213141516171819202122232425&#123;“capabilities”: [ &#123; “browserName”: “internet explorer”, “maxInstances”: 3, “seleniumProtocol”: “WebDriver” &#125; ],“proxy”: “org.openqa.grid.selenium.proxy.DefaultRemoteProxy”,“maxSession”: 3,“port”: 5555,“register”: true,“registerCycle”: 5000,“hub”: “http://localhost:4444“,“nodeStatusCheckTimeout”: 5000,“nodePolling”: 5000,“role”: “node”,“unregisterIfStillDownAfter”: 60000,“downPollingLimit”: 2,“debug”: false,“servlets” : [],“withoutServlets”: [],“custom”: &#123;&#125;&#125; 下载selenium-server-standalone-3.0.1.jar 下载地址：https://selenium-release.storage.googleapis.com/3.0/selenium-server-standalone-3.0.1.jar 部署命令1java -jar selenium-server-standalone.jar -role node -nodeConfig nodeconfig.json 6 已解决的问题我所用的原始Selenium Grid Docker镜像中有中文乱码问题，需要在docker file中加入字符集解决。Selenium Grid中存在监控功能并不完善，若想要获取此类信息数据，需要加入自定义servlet（关于此章我会在另一片文章中介绍）","tags":[{"name":"Selenium Grid","slug":"Selenium-Grid","permalink":"https://yangle94.github.io/tags/Selenium-Grid/"},{"name":"Docker","slug":"Docker","permalink":"https://yangle94.github.io/tags/Docker/"}]},{"title":"java内部类实现原理以及注意事项","date":"2016-12-28T07:08:32.000Z","path":"2016/12/28/innerClass/","text":"1.什么是内部类：定义在某个类中的类叫做内部类。 2.内部类有什么好处：1）内部类方法可以访问类定义所在的做哦用语中的数据，包括私有数据。2）内部类可以对同一个包中的其他类隐藏起来。3）当想要定义一个回调函数且又不想编写大量代码的时候，使用匿名内部类比较便捷。 3.内部类实现原理代码样例:12345678910111213141516171819class TalkingClock &#123; private int interval; private boolean beep; public TalkingClock(int interval, boolean beep) &#123; this.interval = interval; this.beep = beep; &#125; public void start() &#123; ActionListener listener = new TimePrinter(); Time t = new Time(interval,listener); t.start(); &#125; public class TimePrinter implements ActionListener &#123; public void actionPerformed(ActionEvent event) &#123; Date now = new Date(); if(beep) Toolkit.getDefaultToolkit().beep(); &#125; &#125;&#125; 解释:首先，内部类是一种编译器现象，与java虚拟机无关。也就是说，在虚拟机中，类并不存在内部类一说。在上面两个类中，TimePrinterl类是TalkingClock的内部类，当java编译器对此两个类进行编译时，会将内部类TimePrinter编译为TalkingClock$TimePrinter，并在内部类中增加一条外部类的引用，以此来访问外部类对象中的域，并会修改其无参的构造方法为有参的构造方法（增加一个TalkingClock参数），对于外部类TalkingClock，会增加一个static boolean access$0(TalkingClock)方法，具体可以使用java -private innerClass.TalkingClock$TimePrinter(由于在linux等系统的shell中$为关键字，所以此时需要转义)查看。 123456789101112public class TalkingClock$TimePrinter &#123; public TalkingClock$TimePrinter(TalkingClock); public void actionPerformed(java.awt.event.ActionEvent); final TalkingClock this$0;&#125;class TalkingClock &#123; private int interval; private boolean beep; public TalkingClock(int interval, boolean beep); public void start(); static boolean access$0(TalkingClock);&#125; 由此，当内部类中需要访问外部类的私有成员时，内部类可以调用外部类的静态方法进行对私有成员的访问。当然，access$0并不是一个合法的java方法名，因此，在java层面调用此方法名并不现实。但可以用底层的其他方法进行对此方法的调用。","tags":[{"name":"Java","slug":"Java","permalink":"https://yangle94.github.io/tags/Java/"}]},{"title":"jq的ajax请求后台未出错却进入error问题","date":"2016-12-27T07:08:32.000Z","path":"2016/12/27/jqAjaxResError/","text":"现象:1234567891011121314jq进行ajax请求，后端并为报错，状态码为200但ajax请求进入error方法。 $.ajax(&#123; url : \"http:/www.baidu.com\", data : &#123; param : \"param\" &#125; dataType : \"json\", success : function(data) &#123; alert(\"返回成功，进入成功方法\"); &#125; error : function() &#123; alert(\"返回失败，进入失败方法\") &#125; &#125;) 检查思路:1.查看后端日志，发现后端并未报错。2.打开谷歌浏览器调试模式，发现状态吗为200。 由此可推断出后台并为发生任何异常，判断并不是因为后端错误所导致。由此可以判断能够接触到返回数据并出现错误的只能是js部分。 最终结果查询资料后发现，对于ajax请求如果规定了返回值的格式（dataType），则返回值一定要符合dataType的格式。若返回的格式跟dataType的格式不相符，js会在解析的时候报错，由此进入了error的方法。后端以前返回值为”success”，将其改为{“isSuccess” : “success”}后进行返回，程序运行成功，进入ajax的success方法。由此可见，若规定了dataType以后，后端返回的数据必须符合此格式，否则，前端js在解析的时候会发生错误。","tags":[{"name":"ajax","slug":"ajax","permalink":"https://yangle94.github.io/tags/ajax/"},{"name":"jq","slug":"jq","permalink":"https://yangle94.github.io/tags/jq/"}]},{"title":"开博了～","date":"2016-12-25T07:08:32.000Z","path":"2016/12/25/index/","text":"哈哈，功夫不负有心人，终于在github page上开了自己的博客，顿时兴奋无比。 本站主要是用在我个人写的一些程序中遇到的问题。本人初出茅庐，希望大家能够不吝赐教。本次仅仅是为了测试搭成的框架是否可以运行，稍后会写一个博客的搭建教程。","tags":[{"name":"other","slug":"other","permalink":"https://yangle94.github.io/tags/other/"}]}]